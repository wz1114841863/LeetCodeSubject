# 二叉树的遍历

**先序遍历**：**先访问根节点**，再前序遍历左子树，再前序遍历右子树

**中序遍历**：先中序遍历左子树，**再访问根节点**，再中序遍历右子树 

**后序遍历**：先后序遍历左子树，再后序遍历右子树，**再访问根节点**

注：

1.以根节点的访问顺序决定遍历方式。

2.左子树总是优先于右子树。

## 树的结构

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
```

## 递归版本

```
//前序遍历实现
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
    	//返回结果
    	vector<int> res;
    	preorder(res, root);
    	
    	return res;
    }
    void preorder(vector<int> &res, TreeNode* root){
    	//边界条件
    	if( root == nullptr){
    		return ;
    	}
    	//入栈
    	res.emplace_back(root->val);
    	//递归
    	preorder(res, root->left);
    	preorder(res, root->right);
    	
    	return ;
    }
}；
```

```
//中序遍历实现
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
    	//返回结果
    	vector<int> res;
    	inorder(res, root);
    	
    	return res;
    }
    void inorder(vector<int> &res, TreeNode* root){
    	//边界条件
    	if( root == nullptr){
    		return ;
    	}
    	//左子树递归
    	inorder(res, root->left);    	
    	//入栈
    	res.emplace_back(root->val);
    	//右子树递归
    	inorder(res, root->right);
    	
    	return ;
    }
};
```

```
//后序遍历实现
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
    	//返回结果
    	vector<int> res;
    	postorder(res, root);
        return res;
    }
    void postorder(vector<int> &res, TreeNode* root){
    	//边界条件
    	if( root == nullptr){
    		return ;
    	}

    	//递归
    	postorder(res, root->left);
    	postorder(res, root->right);
    	//入栈
    	res.emplace_back(root->val);
        
    	return ;
    }
};
```

## 迭代版本

```
//前序遍历实现
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
    	//返回结果
    	vector<int> res;
    	//使用栈来存储树节点
    	stack<TreeNode*> nodeStack;
    	//根节点入栈
    	if(root != nullptr){
            nodeStack.emplace(root);
        }else{
            return res;
        }
    	//迭代
    	while(!nodeStack.empty()){
    		//出栈
    		TreeNode *node = nodeStack.top();
    		nodeStack.pop();
    		//存储值
    		res.emplace_back(node->val);
    		if(node->right != nullptr) nodeStack.emplace(node->right);
    		if(node->left != nullptr) nodeStack.emplace(node->left);
    	}
    	
    	return res;
    }
};
```

