# 基本技能

1. nullptr 处理。
2. dummy node 哑巴节点。
3. 快慢指针。
4. 双指针。
5. 插入节点到有序链表。
6. 从一个链表中移除一个节点。
7. 翻转链表。
8. merge合并链表。
9. 找到链表的中心节点。

## 双指针



## 哑巴节点

如果头节点可能被删除，可以添加一个哑巴节点类充当头节点。

使用哑节点可以避开一些需要对头节点进行讨论的情形。

```
ListNode *nummyNode = new ListNode(0, head);
```

## 快慢指针

### 作用

1.仅遍历一次确定链表的中心节点位置

```c++
//示例
//这里的范围使用左闭右开区间
ListNode* getMiddle(ListNode* left, ListNode* right){
    //首先建立快慢指针，起始点都为左指针left。
    Listnode *fast = left, *slow = left;
    while(fast!=right && fast->next!=right){  
        //快指针每次走两步，慢指针每次走一步。
        fast = fast->next;
        fast = fast->next;
        slow = slow->next;
    }
    
    return slow;
}
/*
	根据条件 fast!=right && fast->next!=right
	如果为[left, right)为偶数（不包括right)，则fast指向right时，slow指向中间偏右
	如果为[left, right)为奇数数（不包括right)，则fast指向right的前一个指针时，即fast->next = right，slow指向中间	
*/
```

## merge合并

```
//双路合并函数
ListNode* merge(ListNode* L1, ListNode* L2){
	//返回结果
    ListNode *res = new ListNode(-1), *toil = res;
    while(L1 && L2){
    	if(L1->val < L2->val){
   			toil->next = L1;
    		toil = toil->next;
   			 L1 = L1->next;
    	}else{
    		toil->next = L2;
    		toil = toil->next;
   		 	L2 = L2->next;
    	}
    }
    //其中一个链表为空时
    toil->next = L1 ? L1 : L2;

    return res->next;
}
```

## split 操作

将链表 `l` 切掉前 n 个节点，并返回后半部分的链表头。

```
//spilt操作
//返回指向L1的第n+1个节点指针
ListNode* cut(ListNode* L1, int n){
    ListNode* p = L1;
    //判断链表的长度是否大于等于n，并获取第n-1个节点的指针。
    while( --n && p){
        p = p->next;
    }
    if(!p) return nullptr;
    //处理第n-1个节点的末尾，添加nullptr。
    auto res = p->next;
    p->next = nullptr;
    return res;
}
```

